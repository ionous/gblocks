package gblocks

import (
	"github.com/ionous/errutil"
	r "reflect"
)

// Prepare the mutator's dialog with this block's components.
// just like the original code, this goes from the *data* not the workspace block ui
func (b *Block) decompose(blockws, mutationws *Workspace) (ret *Block, err error) {
	// get the predefined mutator block used for the dialog
	if container, e := mutationws.NewBlock(b.Type + "$mutation"); e != nil {
		err = e
	} else {
		container.InitSvg()
		// if the block has data already, hook it up to the container
		if ctx := blockws.Context(b.Id); ctx.IsValid() {
			srcData := ctx.Elem() // source data
			srcType := srcData.Type()
			// the input names match the field names of the data.
			for i, cnt := 0, container.NumInputs(); i < cnt; i++ {
				in := container.Input(i)
				name := in.Name.FieldName()
				connection := in.Connection()
				// connect each data element to the mutation's ui input
				if elsInfo, ok := srcType.FieldByName(name); !ok {
					panic("?")
				} else {
					els := srcData.FieldByIndex(elsInfo.Index)
					//  "cant call Len on Input"
					if cnt := els.Len(); cnt > 0 {
						mutationType := elsInfo.Tag.Get("mutation")
						mutationTypes := TheRegistry.mutations[mutationType]
						//
						for i := 0; i < cnt; i++ {
							iface := els.Index(i)
							ptr := iface.Elem()
							el := ptr.Elem()
							//
							elType := toTypeName(el.Type())
							if mutationType, ok := mutationTypes[elType]; !ok {
								e := errutil.New("couldnt find type", elType)
								err = errutil.Append(err, e)
							} else {
								println(elType, mutationType.Name())

								if block, e := mutationws.NewBlock(mutationType); e != nil {
									err = errutil.Append(err, e)
								} else {
									block.InitSvg()
									connection.Connect(block.PreviousConnection())
									connection = block.NextConnection()
								}
							}
						}
					}
				}
			}
		}
		if err == nil {
			ret = container
		} else {
			container.Dispose()
		}
	}
	return
}

// "into" each mutation ui block
// ( found by looking into the container block -- the blocks connected to the inputs )
// store links to the connections of the blocks in the workspace
// ( so that reordering the mutations can re-order the connections )
func (b *Block) saveConnections(ws *Workspace, containerBlock *Block) {
	// for each input in the mutation ui
	for mi, mcount := 0, containerBlock.NumInputs(); mi < mcount; mi++ {
		firstInput := containerBlock.Input(mi)
		if c := firstInput.Connection(); c != nil {
			// start with the first block connected to the mutation's ui input
			if itemBlock := c.TargetBlock(); itemBlock != nil {
				// the name of dummy input in the (this) block is the same as the mutation's ui input
				blockInput, baseIndex := b.InputByName(firstInput.Name)
				if m := blockInput.Mutation(); m == nil {
					panic("the input in the block should be a mutation")
				} else {
					// for each sub-block in the workspace block
					for ai, acnt := 0, m.Atoms(); ai < acnt; ai++ {
						atom := m.Atom(ai)
						// for each input in the sub-block, store its outgoing connection
						for ni, ncnt := 0, atom.Connections(); ni < ncnt; ni++ {
							blockInput := b.Input(baseIndex + ni)
							atom.SaveConnection(ni, blockInput)
						}
						// next block in the mutation ui
						if c := itemBlock.NextConnection(); c != nil {
							itemBlock = c.TargetBlock()
						} else {
							break
						}
					}
				}
			}
		}
	}
}

type ConnectionList struct {
	list []*Connection
}

func (cl *ConnectionList) add(c *Connection) {
	cl.list = append(cl.list, c)
}

func (cl *ConnectionList) contains(c *Connection) (ret bool) {
	for _, oc := range cl.list {
		if oc.Object == c.Object {
			ret = true
		}
	}
	return
}

// re/create the workspace blocks from the mutation dialog ui
func (b *Block) Compose(ws *Workspace, containerBlock *Block) {
	// rebuild the block
	ctx := ws.Context(b.Id)
	// for each mutation in the mutator ui
	for mi, mcount := 0, containerBlock.NumInputs(); mi < mcount; mi++ {
		firstInput := containerBlock.Input(mi)
		// ugh.
		el := ctx.Elem()
		elType := el.Type()
		elsInfo, ok := elType.FieldByName(firstInput.Name.FieldName())
		if !ok {
			panic(firstInput.Name)
		}
		mutationType := elsInfo.Tag.Get("mutation")
		mutationTypes := TheRegistry.mutations[mutationType]

		// reset the data generated by a previous mutation.
		els := el.FieldByIndex(elsInfo.Index)
		out := els.Slice(0, 0)

		// recreate the data generated by the current mutation.
		if c := firstInput.Connection(); c != nil {
			// each clause represents one atom of this block.
			for clauseBlock := c.TargetBlock(); clauseBlock != nil; {
				// for each clause, create some data
				typeName := mutationTypes.findWorkspaceType(clauseBlock.Type)
				// append the data to the output array
				if v, e := TheRegistry.NewData(typeName); e != nil {
					panic("Composing " + clauseBlock.Type.String() + " " + e.Error())
				} else {
					out = r.Append(out, v)
				}
				// next clause in the mutation ui ( for this input )
				if c := clauseBlock.NextConnection(); c != nil {
					clauseBlock = c.TargetBlock()
				} else {
					break
				}
			}
			els.Set(out)
		}
	}

	// recreates all dynamic inputs based on the data
	b.updateShape(ws)

	// after re-creating the inputs; re-connect those inputs.
	for bi, bcnt := 0, b.NumInputs(); bi < bcnt; bi++ {
		in := b.Input(bi)
		if m := in.Mutation(); m != nil {
			for ai, acnt := 0, m.Atoms(); ai < acnt; ai++ {
				atom := m.Atom(ai)
				for ni, ncnt := 0, atom.Connections(); ni < ncnt; ni++ {
					bi++
					reconnect(b, bi, atom.Connection(ni))
				}
			}
		}
	}
}
