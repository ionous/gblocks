package gblocks

import (
	"github.com/gopherjs/gopherjs/js"
)

// InputMutation --
// b/c we can't easily extend the existing blockly input types
// we hang optional mutation data off of dummy inputs.
// each mutation generally represent some sort of array --
// each element in the array generates some number of inputs.
// alt: completely refactor blockly to compose blocks out of "sub blocks";
//      merging the concept of arg#/message#, and mutations.
type InputMutation struct {
	*js.Object
	name        string `js:"name"`        // name of the mutation, ex. TestMutation
	totalInputs int    `js:"totalInputs"` // total number of inputs generated by this mutation
	// fix: this seems redundent if the elements are available.
	inputCounts *js.Object `js:"inputCounts"` // number of inputs generated by each element of this mutation.
}

// AddSubBlock - some number of contiguous inputs (already added to the parent block) designate a "sub block".
func (m *InputMutation) AddSubBlock(numInputs int) {
	m.inputCounts.SetIndex(m.inputCounts.Length(), numInputs)
	m.totalInputs += numInputs
}

// SubBlocks - number of sub-blocks / mutation elements used by this mutation.
func (m *InputMutation) SubBlocks() (ret int) {
	if m.inputCounts != nil {
		ret = m.inputCounts.Length()
	}
	return
}

// SubBlockInputCount - the number of contiguous inputs used for a given element of this mutation.
func (m *InputMutation) SubBlockInputCount(i int) int {
	return m.inputCounts.Index(i).Int()
}

// Reset - delete all tracking info about inputs drawn by this mutation.
// Returns the previous total inputs.
func (m *InputMutation) Reset() (ret int) {
	ret, m.totalInputs = m.totalInputs, 0
	m.inputCounts = js.MakeWrapper([]int{})
	return
}

// TotalIputs - total number of contiguous inputs used by all of this mutation's sub-block.
func (m *InputMutation) TotalInputs() int {
	return m.totalInputs
}
