package gblocks

import (
	// "github.com/kr/pretty"
	"github.com/stretchr/testify/require"
	// r "reflect"
	// "github.com/ionous/gblocks/decor"
	"testing"
)

type DecorTest struct {
	Mutant DecorMutation
}

type DecorMutation struct {
	Text              string `decor:"commasAnd"`
	PreviousStatement interface{}
	NextStatement     *DecorMutation `decor:"fullStop"`
}

// func commasAnd(d decor.Setting) (ret string) {

// 		d -> DecorMutation.Text field
// 		parent would be DecorTest?
// 		i think not -- i think it would have to be considered "mutation"
// 		input has a parent of input?
// 		d.Index would be 0
// 		d.Next would be the input generated by
// 		HasPrev?

// 		that's the thing i guess:
// 			this is all in one block.

// 			 "MUTANT/0/TEXT"
// 			 "MUTANT/1/TEXT
// 			 "MUTANT/2/TEXT"

// 	setting := d.Container()
// 	// potentially, we could do this by running multiple decorations:
// 	// first the comma has next, then the is last.
// 	if setting.HasPrev() && setting.IsLast() {
// 		ret = ", and"
// 	} else if setting.HasNext() {
// 		ret = ","
// 	}
// 	return
// }

// func fullStop(d decor.Setting) (ret string) {
// 	if setting.IsNil() {
// 		ret = "."
// 	}
// 	return
// }

// what i

func TestDecorListCreate(t *testing.T) {
	var reg Registry
	require.NoError(t,
		reg.RegisterMutation((*DecorMutation)(nil),
			Mutation{"decor", (*DecorMutation)(nil)},
		), "register mutation")
	require.NoError(t, reg.RegisterBlocks(nil,
		(*DecorMutation)(nil),
		(*DecorTest)(nil),
	), "register blocks")
	ws := NewBlankWorkspace(false)
	ws.idGen = &orderedGenerator{name: "main"}

	three := NewTool(&DecorTest{DecorMutation{
		Text: "one", NextStatement: &DecorMutation{
			Text: "two", NextStatement: &DecorMutation{
				Text: "three"}}}})

	// we test this same behavior in a different way in
	// TestToolMutation
	expected :=
		`<block type="decor_test">` +
			/**/ `<mutation>` +
			/* */ `<atoms name="MUTANT">` +
			/*  */ `<atom type="decor_mutation"/>` +
			/*  */ `<atom type="decor_mutation"/>` +
			/* */ `</atoms>` +
			/**/ `</mutation>` +
			/**/ `<field name="MUTANT/0/TEXT">one</field>` +
			/**/ `<field name="MUTANT/1/TEXT">two</field>` +
			/**/ `<field name="MUTANT/2/TEXT">three</field>` +
			`</block>`
	require.Equal(t, expected, three.OuterHTML(), "toolbox")
	//
	if b := GetBlockly().Xml().DomToBlock(three, ws); b == nil {
		t.Fatal("no block")
	} else {
		x := reduceInputs(b)
		expected := []string{"MUTANT", "MUTANT/0/TEXT", "MUTANT/1/TEXT", "MUTANT/2/TEXT"}
		require.Equal(t, expected, x, "inputs")
	}

	// var d decor.Registry
	// d.Register("commasAnd", commasAnd)
	// d.Register("fullStop", fullStop)
	// // one.
	// // one, and two.
	// // one, two, and three.
	// one := &DecorTest{&DecorMutation{"one", nil}}

	// // two := &DecorTest{&DecorMutation{"one", &DecorMutation{"two", nil}}}
	// three := &DecorTest{&DecorMutation{"one", &DecorMutation{"two", &DecorMutation{"three", nil}}}}
}
