package mutant

import (
	"github.com/ionous/errutil"
	"github.com/ionous/gblocks/block"
)

type muiParser struct {
	mins   *BlockMutations
	target block.Shape // workspace block
	db     Atomizer
}

// mutation ui -> workspace; aka "compose"
func (mp *muiParser) expandInputs(muiContainer block.Shape) (ret AtomizedInputs, err error) {
	out := MakeAtomizedInputs()
	for _, inputName := range mp.mins.Inputs {
		if muiInput, index := muiContainer.InputByName(inputName); index < 0 {
			err = errutil.New("cant find mutable input in mutation ui", inputName)
		} else if atoms, e := mp.expandInput(muiInput); e != nil {
			err = errutil.Append(err, e)
		} else {
			out.SetAtomsForInput(inputName, atoms)
		}
	}
	if err == nil {
		ret = out
	}
	return
}

func (mp *muiParser) expandInput(muiInput block.Input) (ret []string, err error) {
	// find the mutation for the passed input
	name := muiInput.InputName()
	if mutation, ok := mp.mins.GetMutation(name); !ok {
		err = errutil.New("input not mutable", name)
	} else if injector, e := newInjector(mp.target, name); e != nil {
		err = e
	} else if a, e := mp.createAtomsAt(muiInput, mutation, injector); e != nil {
		err = errutil.New("error creating atoms", e)
	} else {
		injector.finalizeInputs()
		ret = a
	}
	return
}

// FIX: refactor?  nearly same as atomParser
// for every block connected to the mutation ui's input...
// return the atoms generated
func (mp *muiParser) createAtomsAt(muiInput block.Input, min Mutation, injector *injector) (ret []string, err error) {
	var atoms []string
	if block.VisitStack(muiInput, func(muiBlock block.Shape) (keepGoing bool) {
		// determine which workspace atom corresponds to the (user selected) mutation ui block
		blockType := muiBlock.BlockType()
		if q, ok := FindQuark(min, blockType); !ok {
			err = errutil.New("unknown atom", blockType)
		} else {
			// inputs generated by this quark are tagged with the name of their originating block
			// we do the same when we use parseAtom to load serialized dom
			atomScope := block.Scope("a", muiBlock.BlockId())
			if args, e := q.Atomize(atomScope, mp.db); e != nil {
				err = e
			} else if e := injector.inject(args); e != nil {
				err = e
			} else {
				atoms = append(atoms, q.Name())
				keepGoing = true
			}
		}
		return // sometimes true
	}) {
		ret = atoms
	}
	return
}
