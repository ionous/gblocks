package mutation

import (
	"github.com/ionous/errutil"
	"github.com/ionous/gblocks/blockly"
)

// Build a mutation ui from existing workspace blocks.
// Called once, each time the mutation ui is opened by the user.
// ( as opposed to compose which gets called repeatedly )
func (mb *mutableBlock) decompose(mui *blockly.Workspace) (ret *blockly.Block, err error) {
	if muiContainer, e := mui.NewBlock(MutationType(mb.block.Type)); e != nil {
		err = e // couldnt get the predefined mutator block used for the dialog
	} else {
		muiContainer.InitSvg()
		// each input in the mui represents an atom in the workspace block
		for i, cnt := 0, muiContainer.NumInputs(); i < cnt; i++ {
			muiInput := muiContainer.Input(i)
			// the input names in the mui match the mutation in the original block
			if mi, inputIndex := mb.mutationByName(muiInput.Name); inputIndex < 0 {
				err = errutil.Append(err, errutil.New("input isnt mutable", muiInput.Name))
			} else if palette, ok := mi.palette(); !ok {
				err = errutil.Append(err, errutil.New("input", muiInput.Name, "has unknown mutation"))
			} else {
				muiConnection := muiInput.Connection()
				// for every atom in the workspace block
				for _, atom := range mi.atoms {
					if mutationType, ok := palette.findMutationType(atom.typeName); !ok {
						err = errutil.Append(err, errutil.New("couldnt find mui type for atom", atom.typeName))
					} else if muiBlock, e := mui.NewBlock(mutationType); e != nil {
						err = errutil.Append(err, e)
					} else {
						muiBlock.InitSvg()
						muiConnection.Connect(muiBlock.PreviousConnection())
						muiConnection = muiBlock.NextConnection()
					}
				}
			}
			if err == nil {
				ret = muiContainer
			} else {
				muiContainer.Dispose()
			}
		}
	}
	return
}

// before we re/compose the workspace blocks/ remember what the connections pointed to
// connections are saved into the muiContainer's blocks
// when the mui blocks are re-ordered, the connections are re-ordered.
func (mb *mutableBlock) saveConnections(muiContainer *blockly.Block) (err error) {
	// for each input in the mutation ui
	for i, cnt := 0, muiContainer.NumInputs(); i < cnt; i++ {
		muiInput := muiContainer.Input(i)
		// get the corresponding input in the workspace
		if mi, inputIndex := mb.mutationByName(muiInput.Name); inputIndex < 0 {
			err = errutil.Append(err, errutil.New("input isnt mutable", muiInput.Name))
		} else {
			atomIndex, atomCnt := 0, len(mi.atoms)
			// visit every block connected to the mutation ui's input
			visitStack(muiInput, func(muiBlock *blockly.Block) bool {
				var cs connections
				// each mutation ui block represents a single atom in the workspace
				// the atom, however, can hold several inputs
				if atomIndex < atomCnt {
					atom := mi.atoms[atomIndex]
					atomIndex++
					// record all of the atom's input...
					for i := 0; i < atom.numInputs; i++ {
						inputIndex++
						in := mb.block.Input(inputIndex)
						cs = cs.appendInput(in)
					}
				}
				// and store them in the mutation ui's block
				mb.blockData.saveConnections(muiBlock, cs)
				return true // keep going
			})
		}
	}
	return
}

// mutation ui -> workspace
func (mb *mutableBlock) compose(muiContainer *blockly.Block) (err error) {
	// remove all the dynamic inputs from the blocks;
	// we're about to recreate/recompose them.
	mb.removeAtoms()

	var savedInputs []savedMutation
	// for each mutation in the mutator ui
	for i, cnt := 0, muiContainer.NumInputs(); i < cnt; i++ {
		muiInput := muiContainer.Input(i)
		// get the corresponding input in the workspace
		if mi, inputIndex := mb.mutationByName(muiInput.Name); inputIndex < 0 {
			e := errutil.New("no input block", muiInput.Name)
			err = errutil.Append(err, e)
		} else if palette, ok := mi.palette(); ok {
			e := errutil.New("input", muiInput.Name, "has unknown mutation")
			err = errutil.Append(err, e)
		} else {
			// for every block connected to the mutation ui's input...
			var savedAtoms []savedConnections
			if visitStack(muiInput, func(muiBlock *blockly.Block) (keepGoing bool) {
				// determine which workspace atom corresponds to the (user selected) mutation ui block
				if atomType, found := palette.findAtomType(muiBlock.Type); !found {
					e := errutil.New("unknown atom type for mutation", muiInput.Name, muiBlock.Type)
					err = errutil.Append(err, e)
				} else if numInputs, e := mi.addAtom(atomType); e != nil {
					err = errutil.Append(err, e)
				} else if cs := mb.blockData.getConnections(muiBlock); cs == nil {
					// can be nil the first time the block gets used
					keepGoing = true
				} else if cnt := len(cs); numInputs != cnt {
					e := errutil.New("sanity check: the inputs generated by the atom", numInputs, "dont match the inputs saved for the atom", cnt, muiInput.Name, atomType)
					err = errutil.Append(err, e)
				} else {
					savedAtoms = append(savedAtoms, savedConnections{cs, numInputs})
					keepGoing = true
				}
				return
			}) {
				savedInputs = append(savedInputs, savedMutation{muiInput.Name, savedAtoms})
			}
		}
	}
	//mb.InitSvg() -- called by the caller in blockly already.
	if err == nil {
		if e := mb.reconnect(savedInputs); e != nil {
			err = e
		}
		// else {
		// 	mb.redecorate(reg.Decor)
		// }
	}
	return
}
