package mutation

// // expand the block type into the args. return a description of mutation.
// func (reg *Registry) buildGroup(it *inspect.Item, argDesc Dict, out *ArgumentBuilder) (ret *mutationDesc, err error) {
// 	if rt, ok := reg.types[it.Limit]; !ok {
// 		err = errutil.New(it.Limit, "group type not registered")
// 	} else {
// 		md := mutationDesc{input: it.Name, mutation: it.Limit}
// 		for _, sub := range rt.Items {
// 			switch sub.Kind {
// 			case inspect.PrevLink: // error?
// 			case inspect.NextLink:
// 				// use the next member to determine the constraints
// 				if cs, e := reg.types.CheckType(sub.Limit); e != nil {
// 					err = errutil.Append(err, e)
// 				} else {
// 					// if atoms are added, their inputs are injected after this argument's edge.
// 					out.addArg(argDesc)
// 					md.constraints = cs
// 				}
// 			default:
// 				// the fields inside a mutation struct have a path of MUTANT/0/...
// 				// the first dynamic elements -- which are not generated by the registry -- are MUTANT/1/...
// 				if e := reg.buildArgDesc(sub, it.Name.Index(0), out); e != nil {
// 					err = errutil.Append(err, e)
// 				}
// 			}
// 		}
// 		if err == nil {
// 			ret = &md
// 		}
// 	}
// 	return
// }
